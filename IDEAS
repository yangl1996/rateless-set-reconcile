.ce
New Transaction Coding

.nf
Choosing degree
.fi
We want to balance low-degree codewords that are easy to decode,
and high-degree codewords that cover more transactions.
The former ensures that decoding will not get stuck, but may convey
no new transaction to the receiver. The latter is hard to decode,
but covers more transactions and is more likely to yield new transactions
to the receiver.
I claim that the degree distribution is independent of transaction rate.


.nf
Choosing transactions
.fi
Always pick from the most recently decoded ones.
We may keep a buffer of the last N decoded transactions and randomly pick from them.
Or, we may use a distribution to decide how likely a transaction of a certain age
will be picked.

Potential improvement: sender may choose transactions that have similar lengths.

.nf
Specifying transactions
.fi
We may use short hashes to specify transactions. 4 bytes per transaction
is probably enough. Note that the metadata cost is independent of transaction rate
if the hash size is fixed and the codeword degree is independent of transaction rate.
(See the claim in Choosing degree.) In reality, the hash size may not be fixed, but
it grows at worst logarithmicaly to the transaction rate. Note that the hash length
determines the false-positive rate. For example, a hash of 16 bits has a false-positive
rate of 1/65536. As a result, extremely-short hashes are fine. We have the
exponential enumeration, checksum, and signature check to back. In summary, we use
this technique to reduce the number of false-positive candidates.

Potential improvement: use hash and transaction length to specify transactions.
A codeword should contain transactions on similar lengths (see Choosing transactions),
so the length only needs to be specified once. The hashes may now be shorter.

Another idea is to use bloom filters. Bloom filters could be faster, and may save
space. To bound false positives, we still need to use the time estimation trick.

.nf
Deciding parameters
.fi
The key parameters to decide are the degree distribution and the selection probability
for transactions of a specific age. We may then do a cutoff on the tail of the selection
probability distribution, so that we drop transactions from the buffer when they are
too old to be selected with any significant probability.


